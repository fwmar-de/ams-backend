generator client {
  provider     = "prisma-client"
  output       = "../generated/prisma"
  moduleFormat = "cjs"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  oid       String    @unique
  mpid      String?   @unique
  name      String
  email     String    @unique
  joinedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  rankId    String?  @db.Uuid
  rank      Rank?    @relation(fields: [rankId], references: [id])
  addressId String?  @db.Uuid
  address   Address? @relation(fields: [addressId], references: [id])

  participations Participation[]
  promotions     Promotion[]

  @@map("users")
}

model Location {
  id   String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name String

  addressId String?  @db.Uuid
  address   Address? @relation(fields: [addressId], references: [id])

  participations Participation[]

  @@map("locations")
}

model Address {
  id          String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  street      String
  houseNumber Int
  zipCode     Int
  city        String
  country     String

  locations Location[]
  users     User[]

  @@map("addresses")
}

model Course {
  id           String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name         String
  abbreviation String

  coursesForRanks       CoursesForRanks[]
  participations        Participation[]
  promotionRequirements PromotionRequirement[]

  @@map("courses")
}

model Participation {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  startDate DateTime
  endDate   DateTime
  passed    Boolean  @default(true)

  locationId String   @db.Uuid
  location   Location @relation(fields: [locationId], references: [id])
  courseId   String   @db.Uuid
  course     Course   @relation(fields: [courseId], references: [id])
  userId     String   @db.Uuid
  user       User     @relation(fields: [userId], references: [id])

  @@map("participations")
}

model Rank {
  id           String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name         String
  abbreviation String
  level        Int    @unique

  users           User[]
  coursesForRanks CoursesForRanks[]
  promotions      Promotion[]
  // Anforderungen, um DIESEN Rang zu erreichen
  requirements    PromotionRequirement[] @relation("TargetRank")
  // Anforderungen, wo dieser Rang als Voraussetzung dient
  requiredFor     PromotionRequirement[] @relation("RequiredRank")

  @@map("ranks")
}

model Promotion {
  id   String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  date DateTime

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id])
  rankId String @db.Uuid
  rank   Rank   @relation(fields: [rankId], references: [id])

  @@map("promotions")
}

model CoursesForRanks {
  courseId String @db.Uuid
  course   Course @relation(fields: [courseId], references: [id])
  rankId   String @db.Uuid
  rank     Rank   @relation(fields: [rankId], references: [id])

  @@id([courseId, rankId])
  @@map("courses_for_ranks")
}

model PromotionRequirement {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  // Zielrang der Beförderung
  rankId String @db.Uuid
  rank   Rank   @relation("TargetRank", fields: [rankId], references: [id])

  type     RequirementType
  minYears Int?

  requiredRankId   String? @db.Uuid
  requiredRank     Rank?   @relation("RequiredRank", fields: [requiredRankId], references: [id])
  requiredCourseId String? @db.Uuid
  requiredCourse   Course? @relation(fields: [requiredCourseId], references: [id])

  // Gleicher groupKey = ODER-Gruppe, Gruppen selbst mit AND verknüpft
  groupKey String?

  @@map("promotion_requirements")
}

enum RequirementType {
  MIN_YEARS_IN_RANK
  MIN_YEARS_TOTAL_SERVICE
  REQUIRED_COURSE
  REQUIRED_PREVIOUS_RANK
}
